---
title: Building Foundation
description: '앱 개발에 필요한 기초 지식 알아보기'
date: 2024-07-17
tags: ['iOS', 'SwiftUI']
authors: ['henry']
---

## Feature Grouping

폴더 구조의 feature grouping은 주로 기능에 기반하여 구성되어 있습니다.
이 방식은 해당 기능에 대한 파일들을 하나로 묶어 놓기 때문에 그 기능 자체에 대한 모듈화와 재사용성이 향상됩니다. 하지만 몇 가지 주의할 점이 있습니다.

1. **모듈 간 의존성 관리:** Feature별로 구분되어 있는 것이 좋지만, 각 feature 사이의 의존성을 잘 관리해야 합니다. 한 feature가 다른 feature에 너무 의존적이면 재사용성이 떨어질 수 있습니다.
2. **중복된 코드와 데이터 모델:** 유사한 기능을 가진 다수의 feature가 있다면, 중복 코드를 방지하고 데이터 모델을 공유할 수 있는 방법을 고려해야 합니다.
3. **큰 프로젝트의 경우 모듈화:** 프로젝트가 커지면 feature 단위로 모듈화를 고려해 볼 수 있습니다. 이는 기능 간의 완전한 분리를 허용하고 각 feature가 독립적으로 개발, 테스트 및 배포될 수 있게 합니다.

모든 이러한 사항을 고려하면서, 프로젝트의 규모와 팀의 구성원들이 효과적으로 협업할 수 있는 방식을 찾아보는 것이 중요합니다.

## High Cohesion

높은 응집력이란 코드의 관련 구성요소를 하나로 묶어 유지하는 능력을 말합니다. 즉 서로 잘 어울리고 동일한 목적이나 도메인을 따르는 코드를 작성하는 것을 의미합니다.

모든 코드가 가변적임을 기억해야 합니다. 기능이 많아지고 커질수록 복잡성이 증가하게 되며 이에 따라 유지보수의 어려움을 겪게됩니다. 이를 해소하거나 감소시키기 위해 높은 응집력을 염두에 두면서 개발을 이어나가야 합니다.

## Low Coupling

낮은 결합도 코드, 완전히 분리된 코드는 다른 컴포넌트에 의존하지 않고 어떤 상황에서도 단독적으로 작동할 수 있습니다. 구체적인 타입(concrete type) 대신에 protocol(interface)을 활용하는 것이 주요 포인트 입니다. Swift에서는 이를 POP(Protocol Oriented Programming)으로 알려져있습니다.

> 사용자는 protocol로 정의된 메서드를 호출할 뿐 사용자는 내부 구현을 모롭니다.  
> 예를 들어 자동차 시동을 걸 때 버튼을 눌러서 사용할뿐 내부적으로 어떤 과정을 거치는지 몰라도 된다.

## Design patterns and Software Principles

POP(Protocol Oriented Programming) 와 SOLID 원칙 그리고 디자인 패턴은 높은 응집력과 낮은 결합도를 유지하는데 가장 좋은 방법입니다.
하지만 항상 모든 기술을 따르기전에 언제 사용해아할지를 이해하는것이 중요합니다. 이를 간과하게 되면 오버엔지니어링으로 오히려 코드의 복잡성과 구현시간이 증가하게 됩니다.

- 단일 책임 원칙(SRP)

  클래스는 변경해야 할 이유가 단 하나만 있어야 합니다. 정의하는 각 클래스 또는 유형은 한 가지 작업만 수행해야 합니다. 그렇다고 메서드 하나만 구현할 수 있다는 의미는 아니며 각 클래스는 집중적이고 전문적인 역할을 수행해야 합니다.

- 개방형/폐쇄형 원칙(OCP)

  모듈 및 함수를 포함한 소프트웨어 엔티티는 확장을 위해서는 개방적이어야 하지만 수정을 위해서는 폐쇄적이어야 합니다. 즉, 필요한 기능을 추가하기 위해 크게 변경하지 않고도 유형의 기능을 확장할 수 있어야 합니다.

- 리스코프 치환 원칙(LSP)

  코드를 손상시키지 않고 클래스를 하위 클래스로 대체하는 것. 동일한 프로토콜을 준수하는 한 다른 유형을 사용할 수 있는 프로토콜을 사용하여 Swift에서도 이 아이디어를 적용할 수 있습니다.
  프로그램의 객체는 해당 프로그램의 정확성을 변경하지 않고 해당 하위 유형의 인스턴스로 대체할 수 있어야 합니다. 즉, 한 객체를 하위 클래스인 다른 객체로 대체했는데 이 대체로 인해 영향을 받는 부분이 손상될 수 있다면 이 원칙을 따르지 않는 것입니다.

- 인터페이스 분리 원칙(ISP)

  모듈은 사용하지 않는 요구사항에 의존해서는 안 됩니다. 한 유형의 전체 동작을 중첩하는 프로토콜을 만드는 대신 다른 사용 사례를 다루는 다른 프로토콜을 만들면 모듈이 필요한 것만 사용하는 데 도움이 됩니다.
  클라이언트가 사용하지 않는 인터페이스에 의존하도록 강요해서는 안 됩니다. 코드의 여러 위치에서 사용할 프로토콜을 설계할 때는 해당 프로토콜을 여러 개의 작은 조각으로 나누고 각 조각에 특정 역할을 부여하는 것이 가장 좋습니다. 이렇게 하면 클라이언트는 필요한 프로토콜의 일부에만 의존하게 됩니다.

- 의존성 역전 원칙(DIP)

  모듈이 외부 종속성에 의존해서는 안 되지만, 모듈이 요구 사항을 충족해야 합니다. 이 원칙은 모듈이 다른 모듈이 아닌 추상화에 의존해야 한다는 것을 말합니다. 예를 들어, 이 원칙을 따르면 앱의 다른 부분의 구체적인 구현에 의존하지 않고도 네트워킹 모듈을 독립적으로 테스트할 수 있습니다.

  구체화가 아닌 추상화에 의존하세요. 코드의 다른 부분이 구체적인 클래스에 종속되어서는 안 됩니다. 이렇게 하면 앱의 각 부분을 연결할 때 구체적인 클래스를 사용하는 대신 프로토콜을 사용하는 것이 좋습니다.

> 기존 프로젝트를 리팩터링할 때 SOLID 원칙을 순서대로 따르는 것은 중요하지 않습니다. 그보다는 올바르게 사용하는 것이 중요합니다.  
> 개발을 할 때 항상 염두에 두어야하고 뒤따라오는 것은 "변화" 입니다. 이러한 앱의 기능을 빠르고 효율적으로 조정 개선 및 확장할 수 있는 유연성이 필요합니다. SOLID 원칙은 코드를 유지 관리하는 데 큰 차이를 만드는 방법입니다.

## What is Dependency Injection?

의존성 주입(DI)은 컴포넌트 간의 결합도를 낮춰 애플리케이션을 테스트, 유지보수 및 확장하기 쉽게 만드는 소프트웨어 설계 패턴입니다.
전통적인 프로그래밍에서는 컴포넌트들이 강하게 결합되어 있어, 개별 컴포넌트를 수정하거나 교체할 때 전체 시스템에 영향을 미치기 쉽습니다.
의존성 주입은 컴포넌트를 분리하여, 애플리케이션의 다른 부분에 영향을 주지 않고도 교체하거나 변경할 수 있는 방법을 제공합니다.

## DI in SwiftUI

DI를 사용할때의 장점은 아래와 같습니다.

- 테스트 가능성: DI를 사용하면 종속성을 쉽게 Mock으로 대체할 수 있으므로 SwiftUI 보기에 대한 단위 테스트를 더 쉽게 작성할 수 있습니다.
- 유연성: DI를 사용하면 종속성을 스왑할 수 있으므로 기본 코드를 수정하지 않고도 애플리케이션의 동작을 변경할 수 있습니다.
- 모듈성: 구성 요소를 분리하면 개별 기능을 독립적으로 개발하고 유지 관리하여 애플리케이션의 복잡성을 줄일 수 있습니다.

SwiftUI 에서는 의존성 주입을 구현하는 몇 가지 방법이 있습니다.
Constructor Injection 나 Environment Injection등이 있습니다. 가장 많이 사용하는 방법은 생성자 주입입니다.

## Constructor Injection

```swift title="CONSTRUCTOR INJECTION" showLineNumbers
class AlphaViewModel {
    let blahService: blahService

    init(blahService: BlahService) {
        self.blahService = blahService
    }
}
// 사용
AlphaViewModel(blahService: blahService)
```

위 방법은 생성자를 통해 의존성을 주입하는 방법 입니다. 편한 방법이지만 다양한 property로 인해 약간 더 복잡해질 수 있습니다.
